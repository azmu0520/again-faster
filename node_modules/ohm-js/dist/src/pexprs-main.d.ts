export class PExpr {
    withSource(interval: any): PExpr;
    source: any;
}
export const any: any;
export const end: any;
export class Terminal extends PExpr {
    constructor(obj: any);
    obj: any;
}
export class Range extends PExpr {
    constructor(from: any, to: any);
    from: any;
    to: any;
    matchCodePoint: boolean;
}
export class Param extends PExpr {
    constructor(index: any);
    index: any;
}
export class Alt extends PExpr {
    constructor(terms: any);
    terms: any;
}
export class Extend extends Alt {
    constructor(superGrammar: any, name: any, body: any);
    superGrammar: any;
    name: any;
    body: any;
}
export class Splice extends Alt {
    constructor(superGrammar: any, ruleName: any, beforeTerms: any, afterTerms: any);
    superGrammar: any;
    ruleName: any;
    expansionPos: any;
}
export class Seq extends PExpr {
    constructor(factors: any);
    factors: any;
}
export class Iter extends PExpr {
    constructor(expr: any);
    expr: any;
}
export class Star extends Iter {
    operator: string;
    minNumMatches: number;
    maxNumMatches: number;
}
export class Plus extends Iter {
    operator: string;
    minNumMatches: number;
    maxNumMatches: number;
}
export class Opt extends Iter {
    operator: string;
    minNumMatches: number;
    maxNumMatches: number;
}
export class Not extends PExpr {
    constructor(expr: any);
    expr: any;
}
export class Lookahead extends PExpr {
    constructor(expr: any);
    expr: any;
}
export class Lex extends PExpr {
    constructor(expr: any);
    expr: any;
}
export class Apply extends PExpr {
    constructor(ruleName: any, args?: any[]);
    ruleName: any;
    args: any[];
    isSyntactic(): boolean;
    toMemoKey(): any;
}
export class UnicodeChar extends PExpr {
    constructor(category: any);
    category: any;
    pattern: any;
}
